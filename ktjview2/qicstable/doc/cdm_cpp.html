<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>custom_data_model.cpp</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<a href="http://www.ics.com/index.html">
<img src="ics.jpg" border="0" alt="ICS">
</a>
<center>
<H2>QicsTable Documentation Set</H2>
</center>
</a></head><body>


<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1><a name="cdm_cpp">custom_data_model.cpp</a>
</h1><div class="fragment"><pre><span class="comment">/****************************************************************************</span>
<span class="comment">** $RCSfile$ $Date$</span>
<span class="comment">**</span>
<span class="comment">** Copyright ( C ) 2002-2003 Integrated Computer Solutions, Inc.</span>
<span class="comment">** All rights reserved.</span>
<span class="comment">**</span>
<span class="comment">** This file is part of an example program for QicsTable.  This example</span>
<span class="comment">** program may be used, distributed and modified without limitation.</span>
<span class="comment">**</span>
<span class="comment">*****************************************************************************/</span>

<span class="preprocessor">#include "custom_data_model.h"</span>


StockPrivate::StockPrivate()
{
}

StockPrivate::~StockPrivate()
{
}


StockDataSet::StockDataSet()
{
}

StockDataSet::~StockDataSet()
{
}

<span class="keywordtype">void</span>
StockDataSet::insertStock(<span class="keywordtype">int</span> position)
{
    <span class="keywordflow">if</span> (position == -1)
    position = _stocks.size();

    StockPrivate *sd = <span class="keyword">new</span> StockPrivate();

    StockList::iterator iter;
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordflow">for</span> (iter = _stocks.begin(); iter != _stocks.end(); ++iter)
    {
    <span class="keywordflow">if</span> (count == position)
        <span class="keywordflow">break</span>;

    count++;
    }

    _stocks.insert(iter, sd);
}

<span class="keywordtype">void</span>
StockDataSet::removeStock(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx)
{
    <span class="keywordflow">if</span> (idx &gt;= _stocks.size())
    <span class="keywordflow">return</span>;

    StockList::iterator iter;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = 0;
    <span class="keywordflow">for</span> (iter = _stocks.begin(); iter != _stocks.end(); ++iter)
    {
    <span class="keywordflow">if</span> (count == idx)
    {
        <span class="keyword">delete</span> (*iter);
        <span class="keywordflow">break</span>;
    }

    count++;
    }
    
    _stocks.erase(iter);
}

QString
StockDataSet::symbol(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx)<span class="keyword"> const</span>
<span class="keyword"></span>{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    <span class="keywordflow">return</span> _stocks.at(idx)-&gt;symbol();
    <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> QString();
}

<span class="keywordtype">void</span>
StockDataSet::setSymbol(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, QString sym)
{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    _stocks.at(idx)-&gt;setSymbol(sym);
}

<span class="keywordtype">float</span>
StockDataSet::high(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx)<span class="keyword"> const</span>
<span class="keyword"></span>{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    <span class="keywordflow">return</span> _stocks.at(idx)-&gt;high();
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> -1.0;
}

<span class="keywordtype">void</span>
StockDataSet::setHigh(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">float</span> val)
{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    _stocks.at(idx)-&gt;setHigh(val);
}

<span class="keywordtype">float</span>
StockDataSet::low(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx)<span class="keyword"> const</span>
<span class="keyword"></span>{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    <span class="keywordflow">return</span> _stocks.at(idx)-&gt;low();
    <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> -1.0;
}

<span class="keywordtype">void</span>
StockDataSet::setLow(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">float</span> val)
{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    _stocks.at(idx)-&gt;setLow(val);
}

<span class="keywordtype">float</span>
StockDataSet::close(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx)<span class="keyword"> const</span>
<span class="keyword"></span>{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    <span class="keywordflow">return</span> _stocks.at(idx)-&gt;close();
    <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> -1.0;
}

<span class="keywordtype">void</span>
StockDataSet::setClose(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">float</span> val)
{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    _stocks.at(idx)-&gt;setClose(val);
}

<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
StockDataSet::volume(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx)<span class="keyword"> const</span>
<span class="keyword"></span>{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    <span class="keywordflow">return</span> _stocks.at(idx)-&gt;volume();
    <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">void</span>
StockDataSet::setVolume(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> val)
{ 
    <span class="keywordflow">if</span> (idx &lt; _stocks.size())
    _stocks.at(idx)-&gt;setVolume(val);
}


StockDataModel::StockDataModel() :
    <a class="code" href="classQicsDataModel.html">QicsDataModel</a>(),
    StockDataSet()
{
    _item = 0;

    <span class="comment">// our data model always has SDM_NumDataItems columns</span>
    setNumColumns(SDM_NumDataItems);
}

StockDataModel::~StockDataModel()
{
    <span class="keyword">delete</span> _item;
}

<span class="keyword">const</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> *
StockDataModel::item(<span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col)<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="comment">// we need to modify the internal _item data member inside</span>
    <span class="comment">// this const method.  This modification is not externally</span>
    <span class="comment">// visible, so this const_cast is ok.</span>
    StockDataModel *self = const_cast&lt;StockDataModel *&gt;(<span class="keyword">this</span>);

    <span class="keywordflow">if</span> (_item)
    <span class="keyword">delete</span> self-&gt;_item;

    <span class="comment">// We create a new QicsDataItem of the appropriate type</span>
    <span class="comment">// and return a const pointer to it.</span>

    <span class="keywordflow">if</span> (row &lt; (<span class="keywordtype">int</span>) _stocks.size())
    {
    <span class="keywordflow">switch</span> (col)
    {
    <span class="keywordflow">case</span> SDM_Symbol:
        self-&gt;_item = <span class="keyword">new</span> <a class="code" href="classQicsDataString.html">QicsDataString</a>(symbol(row));
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Close:
        self-&gt;_item = <span class="keyword">new</span> <a class="code" href="classQicsDataFloat.html">QicsDataFloat</a>(close(row));
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_High:
        self-&gt;_item = <span class="keyword">new</span> <a class="code" href="classQicsDataFloat.html">QicsDataFloat</a>(high(row));
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Low:
        self-&gt;_item = <span class="keyword">new</span> <a class="code" href="classQicsDataFloat.html">QicsDataFloat</a>(low(row));
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Volume:
        self-&gt;_item = <span class="keyword">new</span> <a class="code" href="classQicsDataInt.html">QicsDataInt</a>(volume(row));
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        self-&gt;_item = 0;
    }
    }
    <span class="keywordflow">else</span>
    self-&gt;_item = 0;

    <span class="keywordflow">return</span> _item;
};

<span class="keywordtype">void</span>
StockDataModel::setItem(<span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col, <span class="keyword">const</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> &amp;item)
{
    <span class="keywordflow">if</span> (row &lt; static_cast&lt;int&gt; (numStocks()))
    {
    <span class="comment">// Here, we determine which stock attribute we should be setting</span>
    <span class="comment">// by looking at the column attribute.</span>

    <span class="comment">// The modelChanged() signal will be emitted by the individual</span>
    <span class="comment">// set methods (setSymbol, setClose, etc).</span>

    <span class="keywordflow">switch</span> (col)
    {
    <span class="keywordflow">case</span> SDM_Symbol:
        <span class="keywordflow">if</span> (item.<a class="code" href="classQicsDataItem.html#QicsDataItema5">type</a>() == QicsDataItem_String)
        {
        <span class="keyword">const</span> <a class="code" href="classQicsDataString.html">QicsDataString</a> *ds =
            static_cast&lt;const QicsDataString *&gt; (&amp;item);
        setSymbol(row, ds-&gt;<a class="code" href="classQicsDataString.html#QicsDataStringa12">data</a>());
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Close:
        <span class="keywordflow">if</span> (item.<a class="code" href="classQicsDataItem.html#QicsDataItema5">type</a>() == QicsDataItem_Float)
        {
        <span class="keyword">const</span> <a class="code" href="classQicsDataFloat.html">QicsDataFloat</a> *df =
            static_cast&lt;const QicsDataFloat *&gt; (&amp;item);
        setClose(row, df-&gt;<a class="code" href="classQicsDataFloat.html#QicsDataFloata10">data</a>());
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_High:
        <span class="keywordflow">if</span> (item.<a class="code" href="classQicsDataItem.html#QicsDataItema5">type</a>() == QicsDataItem_Float)
        {
        <span class="keyword">const</span> <a class="code" href="classQicsDataFloat.html">QicsDataFloat</a> *df =
            static_cast&lt;const QicsDataFloat *&gt; (&amp;item);
        setHigh(row, df-&gt;<a class="code" href="classQicsDataFloat.html#QicsDataFloata10">data</a>());
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Low:
        <span class="keywordflow">if</span> (item.<a class="code" href="classQicsDataItem.html#QicsDataItema5">type</a>() == QicsDataItem_Float)
        {
        <span class="keyword">const</span> <a class="code" href="classQicsDataFloat.html">QicsDataFloat</a> *df =
            static_cast&lt;const QicsDataFloat *&gt; (&amp;item);
        setLow(row, df-&gt;<a class="code" href="classQicsDataFloat.html#QicsDataFloata10">data</a>());
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Volume:
        <span class="keywordflow">if</span> (item.<a class="code" href="classQicsDataItem.html#QicsDataItema5">type</a>() == QicsDataItem_Int)
        {
        <span class="keyword">const</span> <a class="code" href="classQicsDataInt.html">QicsDataInt</a> *di =
            static_cast&lt;const QicsDataInt *&gt; (&amp;item);
        setVolume(row, di-&gt;<a class="code" href="classQicsDataInt.html#QicsDataInta10">data</a>());
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">break</span>;
    }
    }
}

<span class="keywordtype">void</span>
StockDataModel::clearItem(<span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col)
{
    <span class="keywordflow">if</span> (row &lt; static_cast&lt;int&gt; (numStocks()))
    {
    <span class="comment">// We determine which stock attribute we should be clearing</span>
    <span class="comment">// by looking at the column attribute.</span>

    <span class="comment">// The modelChanged() signal will be emitted by the individual</span>
    <span class="comment">// set methods (setSymbol, setClose, etc).</span>

    <span class="keywordflow">switch</span> (col)
    {
    <span class="keywordflow">case</span> SDM_Symbol:
        setSymbol(row, QString());
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Close:
        setClose(row, 0.0);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_High:
        setHigh(row, 0.0);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Low:
        setLow(row, 0.0);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> SDM_Volume:
        setClose(row, 0);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">break</span>;
    }
    }
}

<span class="keywordtype">void</span>
StockDataModel::clearModel(<span class="keywordtype">void</span>)
{
    <span class="keywordtype">int</span> nrows = numStocks();

    <span class="comment">// Temporarily turn signal emitting off, so removeStock() doesn't emit</span>
    <span class="comment">// a signal for each row that is removed.</span>

    <span class="keywordtype">bool</span> old_emit = emitSignals();
    setEmitSignals(<span class="keyword">false</span>);

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nrows; ++i)
    {
    removeStock(0);
    }

    <span class="comment">// Restore previous signal emitting setting.</span>

    setEmitSignals(old_emit);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelSizeChanged(numRows(), numColumns());
}

<a class="code" href="QicsDataModel_8h.html#a1">QicsDataModelRow</a>
StockDataModel::rowItems(<span class="keywordtype">int</span> row, <span class="keywordtype">int</span> first_col, <span class="keywordtype">int</span> last_col)<span class="keyword"> const</span>
<span class="keyword"></span>{
    <a class="code" href="QicsDataModel_8h.html#a1">QicsDataModelRow</a> rv;

    <span class="keywordflow">if</span> ((last_col &lt; 0) || (last_col &gt; lastColumn()))
    last_col = lastColumn();

    <span class="comment">// Go through each column in the row and add the data item</span>
    <span class="comment">// to the row vector.</span>

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = first_col; i &lt;= last_col; ++i)
    {
    <span class="keyword">const</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> *itm = item(row, i);

    rv.push_back(itm-&gt;<a class="code" href="classQicsDataItem.html#QicsDataItema1">clone</a>());
    }

    <span class="keywordflow">return</span> rv;
}
 
<a class="code" href="QicsDataModel_8h.html#a0">QicsDataModelColumn</a>
StockDataModel::columnItems(<span class="keywordtype">int</span> col, <span class="keywordtype">int</span> first_row, <span class="keywordtype">int</span> last_row)<span class="keyword"> const</span>
<span class="keyword"></span>{
    <a class="code" href="QicsDataModel_8h.html#a0">QicsDataModelColumn</a> cv;

    <span class="keywordflow">if</span> ((last_row &lt; 0) || (last_row &gt; lastRow()))
    last_row = lastRow();

    <span class="comment">// Go through each row in the column and add the data item</span>
    <span class="comment">// to the column vector.</span>

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = first_row; i &lt;= last_row; ++i)
    {
    <span class="keyword">const</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> *itm = item(i, col);

    cv.push_back(itm-&gt;<a class="code" href="classQicsDataItem.html#QicsDataItema1">clone</a>());
    }

    <span class="keywordflow">return</span> cv;
}

<span class="keywordtype">void</span>
StockDataModel::setRowItems(<span class="keywordtype">int</span> row, <span class="keyword">const</span> QicsDataModelRow &amp;v)
{
    QicsDataModelRow::const_iterator iter;
    <span class="keywordtype">int</span> col = 0;

    <span class="comment">// Temporarily turn signal emitting off, so setItem() doesn't emit</span>
    <span class="comment">// a signal for each cell that is changed.</span>

    <span class="keywordtype">bool</span> old_emit = emitSignals();
    setEmitSignals(<span class="keyword">false</span>);

    <span class="comment">// Iterate through each value in the row vector and use setItem()</span>
    <span class="comment">// to do the actual "setting".</span>

    <span class="keywordflow">for</span> (iter = v.begin(); iter != v.end(); ++iter)
    {
    <span class="keywordflow">if</span> (col &gt; (SDM_NumDataItems - 1))
        <span class="keywordflow">break</span>;

    setItem(row, col++, **iter);
    }

    <span class="comment">// Restore previous signal emitting setting.</span>

    setEmitSignals(old_emit);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelChanged(<a class="code" href="classQicsRegion.html">QicsRegion</a>(row, 0, row, col-1));
}

<span class="keywordtype">void</span>
StockDataModel::setColumnItems(<span class="keywordtype">int</span> col, <span class="keyword">const</span> QicsDataModelColumn &amp;v)
{
    QicsDataModelColumn::const_iterator iter;
    <span class="keywordtype">int</span> row = 0;

    <span class="comment">// Temporarily turn signal emitting off, so setItem() doesn't emit</span>
    <span class="comment">// a signal for each cell that is changed.</span>

    <span class="keywordtype">bool</span> old_emit = emitSignals();
    setEmitSignals(<span class="keyword">false</span>);

    <span class="comment">// Iterate through each value in the column vector and use setItem()</span>
    <span class="comment">// to do the actual "setting".</span>

    <span class="keywordflow">for</span> (iter = v.begin(); iter != v.end(); ++iter)
    {
    <span class="keywordflow">if</span> (row &gt; lastRow())
        <span class="keywordflow">break</span>;

    setItem(row++, col, **iter);
    }

    <span class="comment">// Restore previous signal emitting setting.</span>

    setEmitSignals(old_emit);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelChanged(<a class="code" href="classQicsRegion.html">QicsRegion</a>(0, col, row-1, col));
}

<span class="keywordtype">void</span>
StockDataModel::addRows(<span class="keywordtype">int</span> number_of_rows)
{
    <span class="comment">// We use the existing insertStock() call to do the add, but we</span>
    <span class="comment">// have to emit the required signal so all views will update</span>

    <span class="comment">// Temporarily turn signal emitting off, so insertStock() doesn't emit</span>
    <span class="comment">// a signal for each row that is inserted.</span>

    <span class="keywordtype">bool</span> old_emit = emitSignals();
    setEmitSignals(<span class="keyword">false</span>);

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_rows; ++i)
    {
    insertStock(-1);
    }

    <span class="comment">// Restore previous signal emitting setting.</span>

    setEmitSignals(old_emit);

    <span class="keywordflow">if</span> (emitSignals())
    {
    emit rowsAdded(number_of_rows);
    emit modelSizeChanged(numRows(), numColumns());
    }
}

<span class="keywordtype">void</span>
StockDataModel::addColumns(<span class="keywordtype">int</span>)
{
    <span class="comment">// We don't allow adding columns (each stock has a fixed number</span>
    <span class="comment">// of data points).  So we just return without emitting any signals</span>
}

<span class="keywordtype">void</span>
StockDataModel::insertRows(<span class="keywordtype">int</span> number_of_rows, <span class="keywordtype">int</span> starting_position)
{
    <span class="comment">// We use the existing insertStock() call to do the insert, but we</span>
    <span class="comment">// have to emit the required signal so all views will update</span>

    <span class="comment">// Temporarily turn signal emitting off, so setItem() doesn't emit</span>
    <span class="comment">// a signal for each cell that is changed.</span>

    <span class="keywordtype">bool</span> old_emit = emitSignals();
    setEmitSignals(<span class="keyword">false</span>);

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_rows; ++i)
    {
    insertStock(starting_position);
    }

    <span class="comment">// Restore previous signal emitting setting.</span>

    setEmitSignals(old_emit);

    <span class="keywordflow">if</span> (emitSignals())
    {
    emit rowsInserted(number_of_rows, starting_position);
    emit modelSizeChanged(numRows(), numColumns());
    }
}

<span class="keywordtype">void</span>
StockDataModel::insertColumns(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
{
    <span class="comment">// We don't allow inserting columns (each stock has a fixed number</span>
    <span class="comment">// of data points).  So we just return without emitting any signals</span>
}

<span class="keywordtype">void</span>
StockDataModel::deleteRow(<span class="keywordtype">int</span> row)
{
    <span class="comment">// We use the existing removeStock() call to do the delete, which will</span>
    <span class="comment">// also emit the required signal.</span>

    <span class="keywordflow">if</span> (row &lt; static_cast&lt;int&gt; (numStocks()))
    removeStock(row);
}

<span class="keywordtype">void</span>
StockDataModel::deleteRows(<span class="keywordtype">int</span> num_rows, <span class="keywordtype">int</span> start_row)
{
    <span class="comment">// We use the existing removeStock() call to do the delete, but we</span>
    <span class="comment">// have to emit the required signal so all views will update</span>

    <span class="comment">// Temporarily turn signal emitting off, so setItem() doesn't emit</span>
    <span class="comment">// a signal for each cell that is changed.</span>

    <span class="keywordtype">bool</span> old_emit = emitSignals();
    setEmitSignals(<span class="keyword">false</span>);

    <span class="keywordtype">int</span> num_deleted = 0;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_rows; ++i)
    {
    <span class="keywordflow">if</span> (start_row &lt; static_cast&lt;int&gt; (numStocks()))
    {
        removeStock(start_row);
        num_deleted++;
    }
    }

    <span class="comment">// Restore previous signal emitting setting.</span>

    setEmitSignals(old_emit);

    <span class="keywordflow">if</span> (num_deleted &gt; 0 &amp;&amp; emitSignals())
    {
    emit rowsDeleted(1, num_deleted);
    emit modelSizeChanged(numRows(), numColumns());
    }
}

<span class="keywordtype">void</span>
StockDataModel::deleteColumn(<span class="keywordtype">int</span>)
{
    <span class="comment">// We don't allow deleting columns (each stock has a fixed number</span>
    <span class="comment">// of data points).  So we just return without emitting any signals</span>
}

<span class="keywordtype">void</span>
StockDataModel::deleteColumns(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
{
    <span class="comment">// We don't allow deleting columns (each stock has a fixed number</span>
    <span class="comment">// of data points).  So we just return without emitting any signals</span>
}


<span class="keywordtype">void</span>
StockDataModel::setSymbol(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, QString sym)
{
    <span class="comment">// We call appropriate StockDataSet method here to actually store</span>
    <span class="comment">// the value, and then we emit the required signal.</span>

    StockDataSet::setSymbol(idx, sym);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelChanged(<a class="code" href="classQicsRegion.html">QicsRegion</a>(idx, SDM_Symbol, idx, SDM_Symbol));
}

<span class="keywordtype">void</span>
StockDataModel::setHigh(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">float</span> val)
{
    <span class="comment">// We call appropriate StockDataSet method here to actually store</span>
    <span class="comment">// the value, and then we emit the required signal.</span>

    StockDataSet::setHigh(idx, val);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelChanged(<a class="code" href="classQicsRegion.html">QicsRegion</a>(idx, SDM_High, idx, SDM_High));
}

<span class="keywordtype">void</span>
StockDataModel::setLow(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">float</span> val)
{
    <span class="comment">// We call appropriate StockDataSet method here to actually store</span>
    <span class="comment">// the value, and then we emit the required signal.</span>

    StockDataSet::setLow(idx, val);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelChanged(<a class="code" href="classQicsRegion.html">QicsRegion</a>(idx, SDM_Low, idx, SDM_Low));
}

<span class="keywordtype">void</span>
StockDataModel::setClose(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">float</span> val)
{
    <span class="comment">// We call appropriate StockDataSet method here to actually store</span>
    <span class="comment">// the value, and then we emit the required signal.</span>

    StockDataSet::setClose(idx, val);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelChanged(<a class="code" href="classQicsRegion.html">QicsRegion</a>(idx, SDM_Close, idx, SDM_Close));
}

<span class="keywordtype">void</span>
StockDataModel::setVolume(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> val)
{
    <span class="comment">// We call appropriate StockDataSet method here to actually store</span>
    <span class="comment">// the value, and then we emit the required signal.</span>

    StockDataSet::setVolume(idx, val);

    <span class="keywordflow">if</span> (emitSignals())
    emit modelChanged(<a class="code" href="classQicsRegion.html">QicsRegion</a>(idx, SDM_Volume, idx, SDM_Volume));
}

<span class="keywordtype">void</span>
StockDataModel::insertStock(<span class="keywordtype">int</span> position)
{
    <span class="comment">// We call appropriate StockDataSet method here to actually insert</span>
    <span class="comment">// the row, and then we emit the required signal.</span>

    StockDataSet::insertStock(position);

    setNumRows(numRows() + 1);

    <span class="keywordflow">if</span> (emitSignals())
    {
    <span class="keywordflow">if</span> (position == -1)
        emit rowsAdded(1);
    <span class="keywordflow">else</span>
        emit rowsInserted(1, position);

    emit modelSizeChanged(numRows(), numColumns());
    }
}

<span class="keywordtype">void</span>
StockDataModel::removeStock(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx)
{
    <span class="comment">// We call appropriate StockDataSet method here to actually remove</span>
    <span class="comment">// the row, and then we emit the required signal.</span>

    StockDataSet::removeStock(idx);

    setNumRows(numRows() - 1);

    <span class="keywordflow">if</span> (emitSignals())
    {
    emit rowsDeleted(1, idx);
    emit modelSizeChanged(numRows(), numColumns());
    }
}
</pre></div> <!-- footer -->
<P>
<center>
<font size="1">
All trademarks and copyrights on this page are properties of
their respective owners.<br> The rest is copyright ©1999-2003 Integrated
Computer Solutions, Inc.
</font>
</center>
<!-- end footer -->
