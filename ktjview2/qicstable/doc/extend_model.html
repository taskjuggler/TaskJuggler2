<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Extending the QicsTable Data Model</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<a href="http://www.ics.com/index.html">
<img src="ics.jpg" border="0" alt="ICS">
</a>
<center>
<H2>QicsTable Documentation Set</H2>
</center>
</a></head><body>


<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1><a name="extend_model">Extending the QicsTable Data Model</a>
</h1>This page describes how you can extend the QicsTable Data Model architecture to support your organization's specific requirements. In general, you can extend the data model in two ways: by <a class="el" href="extend_model.html#items">adding a new data type</a>, and by <a class="el" href="extend_model.html#model">implementing a new data model</a>.<h2><a name="items"></a>
Adding a New Data Item Type</h2>
QicsTable provides built-in support for many of the common C++ and Qt data types. In the event that you need to store data that is not natively supported, it is a simple task to create your own data type. All user-defined data types must be a subclass of <a class="el" href="classQicsDataItem.html">QicsDataItem</a>, and must implement all pure virtual methods of that class. An example of a subclass that represents a QPoint is shown below, with a description of each method. (All code is inlined in the class definition for brevity.)<p>
Our new data type is subclassed from <a class="el" href="classQicsDataItem.html">QicsDataItem</a>.<p>
<div class="fragment"><pre><span class="keyword">class </span>QicsDataQPoint : <span class="keyword">public</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a>
{
</pre></div><p>
The actual QPoint value is stored here. <div class="fragment"><pre><span class="keyword">protected</span>:
    QPoint myData;     
</pre></div><p>
The constructors for the class. <div class="fragment"><pre><span class="keyword">public</span>:
    QicsDataQPoint() : <a class="code" href="classQicsDataItem.html">QicsDataItem</a>()
    { }
    QicsDataQPoint(<span class="keyword">const</span> QPoint &amp;p) : <a class="code" href="classQicsDataItem.html">QicsDataItem</a>()
    { setData(p); }
    QicsDataQPoint(<span class="keyword">const</span> QicsDataQPoint &amp;di) : <a class="code" href="classQicsDataItem.html">QicsDataItem</a>()
    { setData(di.data()); }
</pre></div><p>
These methods implement a "virtual constructor" and a "virtual copy constructor". We do this so that it is possible to create a new object of this type (or copy an existing object) without knowing the the type of the original object. <div class="fragment"><pre>    <span class="keyword">inline</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> *create(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> QicsDataQPoint(); }
    <span class="keyword">inline</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> *clone(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> QicsDataQPoint(*<span class="keyword">this</span>); }
</pre></div><p>
The assignment operator. <div class="fragment"><pre>    <span class="keyword">inline</span> <span class="keyword">virtual</span> QicsDataQPoint&amp; operator=(<span class="keyword">const</span> QPoint &amp; p)
    { setData(p); <span class="keywordflow">return</span> *<span class="keyword">this</span>;}
</pre></div><p>
<a class="el" href="classQicsDataItem.html#QicsDataItema5">type()</a> must return <b>QicsDataItem_UserDefined</b>. <a class="el" href="classQicsDataItem.html#QicsDataItema6">typeString()</a> should return a unique string that can identify this data type. There also should be a static method called <b>typeName()</b> that returns the same string. <div class="fragment"><pre>    <span class="keyword">inline</span> <span class="keyword">virtual</span> QicsDataItemType type(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">    </span>{ <span class="keywordflow">return</span> (QicsDataItem_UserDefined); }
    <span class="keyword">inline</span> <span class="keyword">virtual</span> QString typeString(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">    </span>{ <span class="keywordflow">return</span> QicsDataQPoint::typeName(); }
    <span class="keyword">inline</span> <span class="keyword">static</span> QString typeName(<span class="keywordtype">void</span>)
    { <span class="keywordflow">return</span> QString(<span class="stringliteral">"qpoint"</span>); }
</pre></div><p>
<a class="el" href="classQicsDataItem.html#QicsDataItema4">string()</a> should return a string representation of the data item. <a class="el" href="classQicsDataItem.html#QicsDataItema3">setString()</a> should attempt to parse the input string and set the object's value to the parsed value. <div class="fragment"><pre>    <span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">const</span> QString string(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">    </span>{ <span class="keywordflow">return</span> QString(<span class="stringliteral">"(%1, %2)"</span>).arg(myData.x()) .arg(myData.y()); }
    <span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keywordtype">bool</span> setString(<span class="keyword">const</span> QString &amp;str) 
    {
        <span class="comment">// This is very simple.  There should be more error checking</span>
        <span class="comment">// in a robust version of this class</span>

        <span class="keywordtype">int</span> x = (str.right(str.length() - 1)).section(<span class="charliteral">','</span>, 0, 0).toInt();
        <span class="keywordtype">int</span> y = (str.left(str.length() - 1)).section(<span class="charliteral">','</span>, 1, 1).toInt();

        setData(QPoint(x, y));
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
</pre></div><p>
<a class="el" href="">data()</a> should return the native value of this object. <a class="el" href="">setData()</a> should set the value of this object. <div class="fragment"><pre>    <span class="keyword">inline</span> QPoint data(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">    </span>{ <span class="keywordflow">return</span> myData; }
    <span class="keyword">inline</span> <span class="keywordtype">void</span> setData(<span class="keyword">const</span> QPoint &amp; p)
    { myData = p;}
</pre></div><p>
<a class="el" href="classQicsDataItem.html#QicsDataItema7">format()</a> should use the given format string to generate a string representation of the object. The syntax of the format string is not defined. This method is generally used by <a class="el" href="classQicsDataItemFormatter.html">QicsDataItemFormatter</a> to format a data item. <div class="fragment"><pre>    <span class="keyword">inline</span> <span class="keyword">virtual</span> QString format(<span class="keyword">const</span> <span class="keywordtype">char</span> *fmt_string)<span class="keyword"> const</span>
<span class="keyword">    </span>{ QString str; <span class="keywordflow">return</span> str.sprintf(fmt_string, myData.x(), myData.y()); }
</pre></div><p>
<a class="el" href="classQicsDataItem.html#QicsDataItema8">compareTo()</a> should return -1 if the object is "less than" <em>x</em>, 1 if the object is "greater than" <em>x</em>, and 0 if they are equal. This method is used by the sorting routines of <a class="el" href="classQicsTable.html">QicsTable</a>. <div class="fragment"><pre>    <span class="keywordtype">int</span> compareTo(<span class="keyword">const</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> &amp;x)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        assert(this-&gt;type() == x.<a class="code" href="classQicsDataItem.html#QicsDataItema5">type</a>());

        <span class="keyword">const</span> QicsDataQPoint *v = dynamic_cast&lt;const QicsDataQPoint *&gt; (&amp;x);
        assert(v != NULL);

        <span class="keywordflow">if</span> (myData.x() &lt; v-&gt;myData.x())
        <span class="keywordflow">return</span> -1;
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (myData.x() &gt; v-&gt;myData.x())
        <span class="keywordflow">return</span> 1;
        <span class="keywordflow">else</span>
        {
        <span class="keywordflow">if</span> (myData.y() &lt; v-&gt;myData.y())
            <span class="keywordflow">return</span> -1;
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (myData.y() &gt; v-&gt;myData.y())
            <span class="keywordflow">return</span> 1;
        <span class="keywordflow">else</span>
            <span class="keywordflow">return</span> 0;
        }
    }
</pre></div><p>
<a class="el" href="classQicsDataItem.html#QicsDataItema9">encode()</a> encodes the object and its type string into a data stream. The method must first encode the appropriate type string, followed by the object's value.<p>
<a class="el" href="classQicsDataItem.html#QicsDataIteme1">decode()</a> decodes an object from a data stream. When this method is called, it has already been determined that the next object in the stream is of the appropriate type. The method must decode the value from the stream and return a newly allocated object. <div class="fragment"><pre>    <span class="keyword">inline</span> <span class="keywordtype">void</span> encode(QDataStream &amp;ds)<span class="keyword"> const </span>
<span class="keyword">    </span>{ ds &lt;&lt; typeString(); ds &lt;&lt; myData; }
    <span class="keyword">static</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> *decode(QDataStream &amp;ds)
    { QPoint val; ds &gt;&gt; val; <span class="keywordflow">return</span> <span class="keyword">new</span> QicsDataQPoint(val); }
</pre></div><p>
<a class="el" href="classQicsDataItem.html#QicsDataStringe2">fromString()</a> attempts to parse the input string and create a new object from the parsed value. If the parse is successful, a newly allocated object is returned, otherwise, 0 is returned. <div class="fragment"><pre>    <span class="keyword">static</span> <a class="code" href="classQicsDataItem.html">QicsDataItem</a> *fromString(<span class="keyword">const</span> QString &amp;str)
    {
        QicsDataQPoint *qp = <span class="keyword">new</span> QicsDataQPoint();

        <span class="keywordflow">if</span> (qp-&gt;setString(str))
        <span class="keywordflow">return</span> qp;
        <span class="keywordflow">else</span>
        {
        <span class="keyword">delete</span> qp;
        <span class="keywordflow">return</span> 0;
        }
    }
};
</pre></div><p>
The final step to create a new data type is to register the new type. This allows the new type to be used in streaming, drag and drop, and cut and paste operations. If you do not register a type, it can still be used in a data model, but the above operations will not succeed. <div class="fragment"><pre><span class="comment">// Somewhere in the client program, this line must be added</span>
   <a class="code" href="classQicsDataItem.html#QicsDataTimee3">QicsDataItem::registerType</a>(QicsDataQPoint::typeName(),
                              QicsDataQPoint::fromString,
                              QicsDataQPoint::decode);
</pre></div><p>
For the complete code for this example, see <a class="el" href="cdt_example.html">Example - Implementing a New Data Type</a>.<h2><a name="model"></a>
Creating a New Data Model</h2>
QicsTable provides a default data model, <a class="el" href="classQicsDataModelDefault.html">QicsDataModelDefault</a>, that implements the <a class="el" href="classQicsDataModel.html">QicsDataModel</a> API and serves as a good, general purpose data model for the table. There may be instances in which <a class="el" href="classQicsDataModelDefault.html">QicsDataModelDefault</a> is not the best choice however. This can be the case when you have already defined and developed a "data model" abstraction for use in your application. While it is certainly possible to create a <a class="el" href="classQicsDataModelDefault.html">QicsDataModelDefault</a> object and copy all of the data from your model into the new object, this isn't very efficient. Furthermore, this approach requires that you keep the two data model objects "in sync", making sure that changes in one are reflected in the other.<p>
In such a case, a better solution is to define a new subclass of <a class="el" href="classQicsDataModel.html">QicsDataModel</a> that implements the <a class="el" href="classQicsDataModel.html">QicsDataModel</a> API, but uses your existing object for data storage. This will provide a transparent interface between your model and QicsTable. Often, the easiest way to design this subclass is to create a class that inherits from both your existing data model and <a class="el" href="classQicsDataModel.html">QicsDataModel</a>. This allows a single object to fulfill both interfaces, and simplifies the coordination of the two model abstractions.<p>
When subclassing from <a class="el" href="classQicsDataModel.html">QicsDataModel</a>, you must provide implementations for all pure virtual functions. These include:<p>
<ul>
<li><a class="el" href="classQicsDataModel.html#QicsDataModela7">QicsDataModel::item()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli0">QicsDataModel::setItem()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModela10">QicsDataModel::rowItems()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModela12">QicsDataModel::setRowItems()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModela11">QicsDataModel::columnItems()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModela13">QicsDataModel::setColumnItems()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli11">QicsDataModel::addRows()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli12">QicsDataModel::addColumns()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli9">QicsDataModel::insertRows()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli10">QicsDataModel::insertColumns()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli13">QicsDataModel::deleteRow()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli14">QicsDataModel::deleteRows()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli15">QicsDataModel::deleteColumn()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli16">QicsDataModel::deleteColumns()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli17">QicsDataModel::clearItem()</a></li><li><a class="el" href="classQicsDataModel.html#QicsDataModeli18">QicsDataModel::clearModel()</a></li></ul>
<p>
In addition, you must make sure that your new data model object emits the required signals when the model size and/or contents have changed. Remember that not only must the above <a class="el" href="classQicsDataModel.html">QicsDataModel</a> methods emit these signals, but that your existing data model methods that modify the data must emit these signals as well. If not, changes to the data via the original data model interface will not be reflected in the <a class="el" href="classQicsTable.html">QicsTable</a>.<p>
To use your new data model object with a <a class="el" href="classQicsTable.html">QicsTable</a> widget, simply create an instance of your data model and pass its pointer to the <a class="el" href="classQicsTable.html">QicsTable</a> constructor (<a class="el" href="classQicsTable.html#QicsTablea0">QicsTable::QicsTable</a>).<p>
For an example of a custom data model, see <a class="el" href="cdm_example.html">Example - Implementing a New Data Model</a>.<p>
Custom data models also can be used for the headers. The standard <a class="el" href="classQicsTable.html">QicsTable</a> constructor automatically creates two instances of <a class="el" href="classQicsDataModelDefault.html">QicsDataModelDefault</a>, one for the row header and one for the column header. By using the alternate <a class="el" href="classQicsTable.html">QicsTable</a> constructor (<a class="el" href="classQicsTable.html#QicsTablea0">QicsTable::QicsTable</a>), you can use your own data model objects instead. <!-- footer -->
<P>
<center>
<font size="1">
All trademarks and copyrights on this page are properties of
their respective owners.<br> The rest is copyright ©1999-2003 Integrated
Computer Solutions, Inc.
</font>
</center>
<!-- end footer -->
